// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/

//@version=6

// @description Signal Framework Types - Modular type system for advanced signal processing
// Note: Remove library() declaration until framework is finalized and ready for publication

///////////////////////////////////////////////////
// SIGNAL FRAMEWORK CONSTANTS
///////////////////////////////////////////////////

// Default configuration values
DEFAULT_WEIGHT = 1.0
DEFAULT_WEAK_THRESHOLD = 0.3
DEFAULT_STRONG_THRESHOLD = 0.7
DEFAULT_NORMALIZATION = "minmax"
NEUTRAL_EMOJI = "😐"
WARNING_EMOJI = "⚠️"
DEFAULT_CONFIDENCE = 0.0

// Signal strength categories
STRENGTH_INVALID = "invalid"
STRENGTH_WEAK = "weak"
STRENGTH_MODERATE = "moderate"
STRENGTH_STRONG = "strong"

// Normalization schemes
NORM_MINMAX = "minmax"
NORM_ZSCORE = "zscore"
NORM_PERCENTILE = "percentile"

///////////////////////////////////////////////////
// CORE TYPE DEFINITIONS
///////////////////////////////////////////////////
// Individual type definitions using modular partial files

// SignalThought - Lightweight, optional human-readable interpretation
// @type SignalThought
// @field sentiment (simple string) Emoji-based emotional state (e.g., "😐", "🧐", "🚀")
// @field message (simple string) Human-readable explanation
type SignalThought
    string sentiment
    string message

///////////////////////////////////////////////////
// SIGNALTHOUGHT METHODS
///////////////////////////////////////////////////

// @function Converts SignalThought to readable string representation
// @param this (SignalThought) The SignalThought instance
// @returns (string) Formatted string with sentiment emoji and message
method toString(SignalThought this) =>
    this.sentiment + " " + this.message

// @function Checks if SignalThought contains any meaningful content
// @param this (SignalThought) The SignalThought instance
// @returns (bool) True if both sentiment and message are empty strings
method isEmpty(SignalThought this) =>
    this.sentiment == "" and this.message == ""

// SignalDefinition - Immutable declaration of what the signal measures
// @type SignalDefinition
// @field name (simple string) Unique identifier (e.g., "maShortTerm")
// @field description (simple string) Human-readable purpose (e.g., "9-period MA slope trend")
// @field minValue (simple float) Expected minimum value (e.g., -1.0)
// @field maxValue (simple float) Expected maximum value (e.g., +1.0)
// @field category (simple string) Logical grouping (e.g., "trend", "momentum", "volume")
type SignalDefinition
    string name
    string description
    float minValue
    float maxValue
    string category


// SignalInstance - Pure numeric runtime output with optional thoughts
// @type SignalInstance
// @field name (simple string) Reference to SignalDefinition.name
// @field rawValue (series float) Pure numeric output (no interpretation)
// @field confidence (series float) Quality/reliability score 0.0-1.0
// @field thoughts (array<SignalThought>) Optional interpretation layers
type SignalInstance
    string name
    float rawValue
    float confidence
    array<SignalThought> thoughts

///////////////////////////////////////////////////
// SIGNALINSTANCE METHODS
///////////////////////////////////////////////////

// @function Gets the signal name
// @param this (SignalInstance) The SignalInstance instance
// @returns (string) The signal name identifier
method getName(SignalInstance this) => this.name

// @function Gets the raw signal value
// @param this (SignalInstance) The SignalInstance instance
// @returns (float) The raw numeric signal value
method getValue(SignalInstance this) => this.rawValue

// @function Gets the confidence level
// @param this (SignalInstance) The SignalInstance instance
// @returns (float) The confidence score (0.0-1.0)
method getConfidence(SignalInstance this) => this.confidence

// @function Gets the thoughts array
// @param this (SignalInstance) The SignalInstance instance
// @returns (array<SignalThought>) Array of associated thoughts/interpretations
method getThoughts(SignalInstance this) => this.thoughts

// @function Sets the raw signal value (fluent interface)
// @param this (SignalInstance) The SignalInstance instance
// @param value (float) New raw signal value
// @returns (SignalInstance) Self-reference for method chaining
method setValue(SignalInstance this, float value) =>
    this.rawValue := value
    this

// @function Sets the confidence level (fluent interface)
// @param this (SignalInstance) The SignalInstance instance
// @param confidence (float) New confidence score (0.0-1.0)
// @returns (SignalInstance) Self-reference for method chaining
method setConfidence(SignalInstance this, float confidence) =>
    this.confidence := confidence
    this

// @function Adds a new thought with sentiment and message (fluent interface)
// @param this (SignalInstance) The SignalInstance instance
// @param sentiment (string) Emoji-based sentiment ("😐", "🧐", "🚀", "⚠️", etc.)
// @param message (string) Human-readable interpretation message
// @returns (SignalInstance) Self-reference for method chaining
method addThought(SignalInstance this, string sentiment, string message) =>
    thought = SignalThought.new(sentiment = sentiment, message = message)
    array.push(this.thoughts, thought)
    this

// @function Adds an existing SignalThought object (fluent interface)
// @param this (SignalInstance) The SignalInstance instance
// @param thought (SignalThought) Pre-created SignalThought to add
// @returns (SignalInstance) Self-reference for method chaining
method addThoughtObj(SignalInstance this, SignalThought thought) =>
    array.push(this.thoughts, thought)
    this

// @function Checks if signal has any associated thoughts
// @param this (SignalInstance) The SignalInstance instance
// @returns (bool) True if thoughts array contains one or more elements
method hasThoughts(SignalInstance this) => array.size(this.thoughts) > 0

// @function Gets the total number of thoughts
// @param this (SignalInstance) The SignalInstance instance
// @returns (int) Count of thoughts in the thoughts array
method getThoughtCount(SignalInstance this) => array.size(this.thoughts)

// @function Gets a specific thought by index
// @param this (SignalInstance) The SignalInstance instance
// @param index (int) Zero-based index into thoughts array
// @returns (SignalThought) The thought at the specified index
method getThoughtAt(SignalInstance this, int index) =>
    array.get(this.thoughts, index)

// @function Removes all thoughts from the signal (fluent interface)
// @param this (SignalInstance) The SignalInstance instance
// @returns (SignalInstance) Self-reference for method chaining
method clearThoughts(SignalInstance this) =>
    array.clear(this.thoughts)
    this

// @function Checks if signal has any warning thoughts (⚠️ sentiment)
// @param this (SignalInstance) The SignalInstance instance
// @returns (bool) True if any thought has "⚠️" sentiment
method hasWarnings(SignalInstance this) =>
    for i = 0 to array.size(this.thoughts) - 1
        thought = array.get(this.thoughts, i)
        if thought.sentiment == "⚠️"
          true
    false

// @function Gets the most recently added thought
// @param this (SignalInstance) The SignalInstance instance
// @returns (SignalThought or na) Latest thought, or na if no thoughts exist
method getLatestThought(SignalInstance this) =>
    if array.size(this.thoughts) > 0
        array.get(this.thoughts, array.size(this.thoughts) - 1)
    else
        na

// @function Validates if signal has meaningful data
// @param this (SignalInstance) The SignalInstance instance
// @returns (bool) True if rawValue is not na and confidence is positive
method isValid(SignalInstance this) =>
    not na(this.rawValue) and this.confidence > 0.0

// @function Categorizes signal strength based on confidence level
// @param this (SignalInstance) The SignalInstance instance
// @returns (string) Strength category: "invalid", "weak", "moderate", or "strong"
method getStrengthCategory(SignalInstance this) =>
    if na(this.rawValue)
        "invalid"
    else if this.confidence < 0.3
        "weak"
    else if this.confidence < 0.7
        "moderate"
    else
        "strong"

// @type SignalConfiguration
// @field signalName (simple string) References SignalDefinition.name
// @field moduleName (simple string) Module this config applies to (optional for global config)
// @field weight (simple float) Weight for aggregation (default 1.0)
// @field thresholdWeak (simple float) Threshold for weak signals (default 0.3)
// @field thresholdStrong (simple float) Threshold for strong signals (default 0.7)
// @field normalizationScheme (simple string) "minmax", "zscore", "percentile" (default "minmax")
// @field enabled (simple bool) Whether this signal is active (default true)
type SignalConfiguration
    string signalName
    string moduleName
    float weight
    float thresholdWeak
    float thresholdStrong
    string normalizationScheme
    bool enabled

///////////////////////////////////////////////////
// SIGNALCONFIGURATION METHODS
///////////////////////////////////////////////////

// @function Sets the weight for signal aggregation (fluent interface)
// @param this (SignalConfiguration) The SignalConfiguration instance
// @param weight (float) Weight value for signal aggregation (typically 0.1-5.0)
// @returns (SignalConfiguration) Self-reference for method chaining
method setWeight(SignalConfiguration this, float weight) =>
    this.weight := weight
    this

// @function Sets weak and strong signal thresholds (fluent interface)
// @param this (SignalConfiguration) The SignalConfiguration instance
// @param weak (float) Threshold for weak signals (typically 0.1-0.4)
// @param strong (float) Threshold for strong signals (typically 0.6-0.9)
// @returns (SignalConfiguration) Self-reference for method chaining
method setThresholds(SignalConfiguration this, float weak, float strong) =>
    this.thresholdWeak := weak
    this.thresholdStrong := strong
    this

// @function Sets the normalization scheme for signal processing (fluent interface)
// @param this (SignalConfiguration) The SignalConfiguration instance
// @param scheme (string) Normalization method: "minmax", "zscore", or "percentile"
// @returns (SignalConfiguration) Self-reference for method chaining
method setNormalization(SignalConfiguration this, string scheme) =>
    this.normalizationScheme := scheme
    this

// @function Enables this signal configuration (fluent interface)
// @param this (SignalConfiguration) The SignalConfiguration instance
// @returns (SignalConfiguration) Self-reference for method chaining
method enable(SignalConfiguration this) =>
    this.enabled := true
    this

// @function Disables this signal configuration (fluent interface)
// @param this (SignalConfiguration) The SignalConfiguration instance
// @returns (SignalConfiguration) Self-reference for method chaining
method disable(SignalConfiguration this) =>
    this.enabled := false
    this

// @function Factory method to create a new SignalInstance from this configuration
// @param this (SignalConfiguration) The SignalConfiguration instance
// @param rawValue (float) The raw numeric signal value
// @param confidence (float) Optional confidence level (0.0-1.0, default 1.0)
// @returns (SignalInstance) New SignalInstance created with this configuration's signal name
method createSignal(SignalConfiguration this, float rawValue, float confidence = 1.0) =>
    SignalInstance.new(
      this.signalName,
      rawValue,
      confidence,
      array.new<SignalThought>())


// SignalGroup - Group of related signals with aggregated computation and inherited thoughts
// @type SignalGroup
// @field name (simple string) Group identifier (e.g., "Trend", "Entry", "Exit")
// @field description (simple string) Group purpose description
// @field signals (array<SignalInstance>) Member signals
// @field aggregatedSignal (SignalInstance) Aggregated as a single signal instance
type SignalGroup
    string name
    string description
    array<SignalInstance> signals
    SignalInstance aggregatedSignal

///////////////////////////////////////////////////
// SIGNALGROUP METHODS
///////////////////////////////////////////////////

// @function Gets the group name identifier
// @param this (SignalGroup) The SignalGroup instance
// @returns (string) The group name
method getName(SignalGroup this) => this.name

// @function Gets the group description
// @param this (SignalGroup) The SignalGroup instance
// @returns (string) Human-readable description of the group's purpose
method getDescription(SignalGroup this) => this.description

// @function Gets the signals array
// @param this (SignalGroup) The SignalGroup instance
// @returns (array<SignalInstance>) Array of all signals in this group
method getSignals(SignalGroup this) => this.signals

// @function Gets the aggregated signal result
// @param this (SignalGroup) The SignalGroup instance
// @returns (SignalInstance) The computed aggregate signal for the group
method getAggregatedSignal(SignalGroup this) => this.aggregatedSignal

// @function Sets the group description (fluent interface)
// @param this (SignalGroup) The SignalGroup instance
// @param description (string) New description for the group
// @returns (SignalGroup) Self-reference for method chaining
method setDescription(SignalGroup this, string description) =>
    this.description := description
    this

// @function Adds a signal to the group (fluent interface)
// @param this (SignalGroup) The SignalGroup instance
// @param signal (SignalInstance) Signal to add to the group
// @returns (SignalGroup) Self-reference for method chaining
method addSignal(SignalGroup this, SignalInstance signal) =>
    array.push(this.signals, signal)
    this

// @function Removes a signal from the group by name (fluent interface)
// @param this (SignalGroup) The SignalGroup instance
// @param signalName (string) Name of the signal to remove
// @returns (SignalGroup) Self-reference for method chaining
method removeSignal(SignalGroup this, string signalName) =>
    for i = array.size(this.signals) - 1 to 0
        signal = array.get(this.signals, i)
        if signal.name == signalName
            array.remove(this.signals, i)
            break
    this

// @function Checks if group contains a signal with the specified name
// @param this (SignalGroup) The SignalGroup instance
// @param signalName (string) Name of the signal to search for
// @returns (bool) True if signal exists in the group
method hasSignal(SignalGroup this, string signalName) =>
    for i = 0 to array.size(this.signals) - 1
        signal = array.get(this.signals, i)
        if signal.name == signalName
            true
    false

// @function Gets the total number of signals in the group
// @param this (SignalGroup) The SignalGroup instance
// @returns (int) Count of signals in the group
method getSignalCount(SignalGroup this) =>
    array.size(this.signals)

// @function Gets a signal by index position
// @param this (SignalGroup) The SignalGroup instance
// @param index (int) Zero-based index into the signals array
// @returns (SignalInstance) The signal at the specified index
method getSignalAt(SignalGroup this, int index) => array.get(this.signals, index)

// @function Checks if the group has no signals
// @param this (SignalGroup) The SignalGroup instance
// @returns (bool) True if signals array is empty
method isEmpty(SignalGroup this) => array.size(this.signals) == 0

// @function Removes all signals from the group (fluent interface)
// @param this (SignalGroup) The SignalGroup instance
// @returns (SignalGroup) Self-reference for method chaining
method clear(SignalGroup this) =>
    array.clear(this.signals)
    this

// @function Checks if group contains at least one valid signal
// @param this (SignalGroup) The SignalGroup instance
// @returns (bool) True if any signal in the group passes isValid() check
method hasValidSignals(SignalGroup this) =>
    for i = 0 to array.size(this.signals) - 1
        signal = array.get(this.signals, i)
        if signal.isValid()
            true
    false

// @function Gets array of all valid signals in the group
// @param this (SignalGroup) The SignalGroup instance
// @returns (array<SignalInstance>) New array containing only valid signals
method getValidSignals(SignalGroup this) =>
    validSignals = array.new<SignalInstance>()
    for i = 0 to array.size(this.signals) - 1
        signal = array.get(this.signals, i)
        if signal.isValid()
            array.push(validSignals, signal)
    validSignals

// @function Counts signals in the group that have warning thoughts
// @param this (SignalGroup) The SignalGroup instance
// @returns (int) Number of signals containing warnings (⚠️ sentiment thoughts)
method getTotalWarnings(SignalGroup this) =>
    warningCount = 0
    for i = 0 to array.size(this.signals) - 1
        signal = array.get(this.signals, i)
        if signal.hasWarnings()
            warningCount += 1
    warningCount


// SignalRegistry - Registry for managing definitions, configurations, and runtime groups
// @type SignalRegistry
// @field definitions (map<string, SignalDefinition>) Static signal definitions keyed by name
// @field configurations (map<string, SignalConfiguration>) Per-instance behavior settings keyed by signalName
// @field groups (map<string, SignalGroup>) Runtime signal groups keyed by group name
type SignalRegistry
    map<string, SignalDefinition> definitions
    map<string, SignalConfiguration> configurations
    map<string, SignalGroup> groups

///////////////////////////////////////////////////
// SIGNALREGISTRY METHODS
///////////////////////////////////////////////////

// @function Adds a signal definition to the registry (fluent interface)
// @param this (SignalRegistry) The SignalRegistry instance
// @param definition (SignalDefinition) Signal definition to register
// @returns (SignalRegistry) Self-reference for method chaining
method addDefinition(SignalRegistry this, SignalDefinition definition) =>
    this.definitions.put(definition.name, definition)
    this

// @function Adds a signal configuration to the registry (fluent interface)
// @param this (SignalRegistry) The SignalRegistry instance
// @param config (SignalConfiguration) Configuration to register
// @returns (SignalRegistry) Self-reference for method chaining
method addConfiguration(SignalRegistry this, SignalConfiguration config) =>
    this.configurations.put(config.signalName, config)
    this

// @function Adds a signal group to the registry (fluent interface)
// @param this (SignalRegistry) The SignalRegistry instance
// @param group (SignalGroup) Group to register
// @returns (SignalRegistry) Self-reference for method chaining
method addGroup(SignalRegistry this, SignalGroup group) =>
    this.groups.put(group.name, group)
    this

// @function Checks if a signal definition exists by name - O(1) lookup
// @param this (SignalRegistry) The SignalRegistry instance
// @param name (string) Signal name to check
// @returns (bool) True if definition exists in registry
method hasDefinition(SignalRegistry this, string name) =>
    this.definitions.contains(name)

// @function Gets a signal definition by name - O(1) lookup
// @param this (SignalRegistry) The SignalRegistry instance
// @param name (string) Signal name to retrieve
// @returns (SignalDefinition or na) Definition if exists, na otherwise
method getDefinition(SignalRegistry this, string name) =>
    this.definitions.get(name)

// @function Gets a signal configuration by signal name - O(1) lookup
// @param this (SignalRegistry) The SignalRegistry instance
// @param name (string) Signal name to retrieve configuration for
// @returns (SignalConfiguration or na) Configuration if exists, na otherwise
method getConfiguration(SignalRegistry this, string name) =>
    this.configurations.get(name)

// @function Gets a signal group by name - O(1) lookup
// @param this (SignalRegistry) The SignalRegistry instance
// @param name (string) Group name to retrieve
// @returns (SignalGroup or na) Group if exists, na otherwise
method getGroup(SignalRegistry this, string name) =>
    this.groups.get(name)

// @function Gets the total number of registered signal definitions
// @param this (SignalRegistry) The SignalRegistry instance
// @returns (int) Count of definitions in the registry
method getDefinitionCount(SignalRegistry this) =>
    this.definitions.size()

// @function Gets the total number of registered signal configurations
// @param this (SignalRegistry) The SignalRegistry instance
// @returns (int) Count of configurations in the registry
method getConfigurationCount(SignalRegistry this) =>
    this.configurations.size()

// @function Gets the total number of registered signal groups
// @param this (SignalRegistry) The SignalRegistry instance
// @returns (int) Count of groups in the registry
method getGroupCount(SignalRegistry this) =>
    this.groups.size()

// @function Validates that a signal name has a registered definition
// @param this (SignalRegistry) The SignalRegistry instance
// @param name (string) Signal name to validate
// @returns (bool) True if signal has a definition in the registry
method validateSignalName(SignalRegistry this, string name) =>
    this.hasDefinition(name)

// @function Gets array of all registered definition names in insertion order
// @param this (SignalRegistry) The SignalRegistry instance
// @returns (array<string>) Array of all definition names/keys
method getAllDefinitionNames(SignalRegistry this) =>
    this.definitions.keys()

// @function Gets array of all registered configuration names in insertion order
// @param this (SignalRegistry) The SignalRegistry instance
// @returns (array<string>) Array of all configuration signal names/keys
method getAllConfigurationNames(SignalRegistry this) =>
    this.configurations.keys()

// @function Gets array of all registered group names in insertion order
// @param this (SignalRegistry) The SignalRegistry instance
// @returns (array<string>) Array of all group names/keys
method getAllGroupNames(SignalRegistry this) =>
    this.groups.keys()

// @function Removes a signal definition from the registry (fluent interface)
// @param this (SignalRegistry) The SignalRegistry instance
// @param name (string) Name of definition to remove
// @returns (SignalRegistry) Self-reference for method chaining
method removeDefinition(SignalRegistry this, string name) =>
    this.definitions.remove(name)
    this

// @function Removes a signal configuration from the registry (fluent interface)
// @param this (SignalRegistry) The SignalRegistry instance
// @param name (string) Signal name of configuration to remove
// @returns (SignalRegistry) Self-reference for method chaining
method removeConfiguration(SignalRegistry this, string name) =>
    this.configurations.remove(name)
    this

// @function Removes a signal group from the registry (fluent interface)
// @param this (SignalRegistry) The SignalRegistry instance
// @param name (string) Name of group to remove
// @returns (SignalRegistry) Self-reference for method chaining
method removeGroup(SignalRegistry this, string name) =>
    this.groups.remove(name)
    this

// @function Clears all registries (definitions, configurations, groups) (fluent interface)
// @param this (SignalRegistry) The SignalRegistry instance
// @returns (SignalRegistry) Self-reference for method chaining
method clear(SignalRegistry this) =>
    this.definitions.clear()
    this.configurations.clear()
    this.groups.clear()
    this


// SignalsFramework - Static namespace with hosted registry for framework operations
// @type SignalsFramework
// @field registry (SignalRegistry) Hosted registry for signals
type SignalsFramework
    SignalRegistry registry

///////////////////////////////////////////////////
// SIGNALSFRAMEWORK METHODS
///////////////////////////////////////////////////
// SIGNALSFRAMEWORK METHODS
///////////////////////////////////////////////////

// @function Gets the hosted registry instance
// @param this (SignalsFramework) The SignalsFramework instance
// @returns (SignalRegistry) The hosted registry containing all definitions, configurations, and groups
method getRegistry(SignalsFramework this) => this.registry

// @function Registers a signal definition with the hosted registry (fluent interface)
// @param this (SignalsFramework) The SignalsFramework instance
// @param definition (SignalDefinition) Definition to register
// @returns (SignalsFramework) Self-reference for method chaining
method register(SignalsFramework this, SignalDefinition definition) =>
    this.registry.addDefinition(definition)
    this

// @function Registers a signal configuration with the hosted registry (fluent interface)
// @param this (SignalsFramework) The SignalsFramework instance
// @param config (SignalConfiguration) Configuration to register
// @returns (SignalsFramework) Self-reference for method chaining
method register(SignalsFramework this, SignalConfiguration config) =>
    this.registry.addConfiguration(config)
    this

// @function Registers a signal group with the hosted registry (fluent interface)
// @param this (SignalsFramework) The SignalsFramework instance
// @param group (SignalGroup) Group to register
// @returns (SignalsFramework) Self-reference for method chaining
method register(SignalsFramework this, SignalGroup group) =>
    this.registry.addGroup(group)
    this

// @function Factory method to create a new signal definition
// @param this (SignalsFramework) The SignalsFramework instance
// @param name (string) Unique identifier for the signal
// @param description (string) Human-readable description of signal purpose
// @param minValue (float) Minimum expected value for the signal
// @param maxValue (float) Maximum expected value for the signal
// @param category (string) Signal category for grouping (e.g., "trend", "momentum", "volume")
// @returns (SignalDefinition) New signal definition ready for registration
method createDefinition(SignalsFramework this,
  string name, string description, float minValue, float maxValue, string category) =>
    SignalDefinition.new(name, description, minValue, maxValue, category)

// @function Factory method to create a new signal configuration with defaults
// @param this (SignalsFramework) The SignalsFramework instance
// @param signalName (string) Name of the signal this configuration applies to
// @param moduleName (string) Optional module name for scoped configurations (default "")
// @param weight (float) Aggregation weight for this signal (default 1.0)
// @returns (SignalConfiguration) New configuration with standard thresholds and normalization
method createConfiguration(SignalsFramework this,
  string signalName, string moduleName = "", float weight = 1.0) =>
    SignalConfiguration.new(
      signalName, moduleName, weight, 0.3, 0.7, "minmax", true)

// @function Factory method to create a new signal registry with empty maps
// @param this (SignalsFramework) The SignalsFramework instance
// @returns (SignalRegistry) New registry with empty maps for definitions, configurations, and groups
method createRegistry(SignalsFramework this) =>
    SignalRegistry.new(
      map.new<string, SignalDefinition>(),
      map.new<string, SignalConfiguration>(),
      map.new<string, SignalGroup>())

// @function Factory method to create a new signal group with empty aggregated signal
// @param this (SignalsFramework) The SignalsFramework instance
// @param name (string) Group identifier
// @param description (string) Purpose description for the group
// @returns (SignalGroup) New group with empty signals array and placeholder aggregated signal
method createGroup(SignalsFramework this, string name, string description) =>
    SignalGroup.new(
      name, description,
      array.new<SignalInstance>(),
      SignalInstance.new("", 0.0, 0.0, array.new<SignalThought>()))


///////////////////////////////////////////////////
// SIGNALS FRAMEWORK NAMESPACE
///////////////////////////////////////////////////
// Elegant namespace pattern with hosted registry

// Create the singleton namespace instance with hosted registry
signals = SignalsFramework.new(
    SignalRegistry.new(
      array.new<SignalDefinition>(),
      array.new<SignalConfiguration>(),
      array.new<SignalGroup>()))

// Registry access methods
method getRegistry(SignalsFramework this) => this.registry
method register(SignalsFramework this, SignalDefinition definition) =>
    this.registry.definitions.push(definition)
    this

method register(SignalsFramework this, SignalConfiguration config) =>
    this.registry.configurations.push(config)
    this

method register(SignalsFramework this, SignalGroup group) =>
    this.registry.groups.push(group)
    this

// SignalsFramework namespace methods for creating definitions and configurations
method createDefinition(SignalsFramework this,
  string name, string description, float minValue, float maxValue, string category) =>
    SignalDefinition.new(name, description, minValue, maxValue, category)

method createConfiguration(SignalsFramework this,
  string signalName, string moduleName = "", float weight = 1.0) =>
    SignalConfiguration.new(
      signalName, moduleName, weight, 0.3, 0.7, "minmax", true)

method createRegistry(SignalsFramework this) =>
    SignalRegistry.new(
      array.new<SignalDefinition>(),
      array.new<SignalConfiguration>(),
      array.new<SignalGroup>())

method createGroup(SignalsFramework this, string name, string description) =>
    SignalGroup.new(
      name, description,
      array.new<SignalInstance>(),
      SignalInstance.new("", 0.0, 0.0, array.new<SignalThought>()))

///////////////////////////////////////////////////
// BASIC TYPE METHODS
///////////////////////////////////////////////////
// Methods are now embedded directly in their type partials
// This file is preserved for backwards compatibility but no longer needed

// Types with embedded methods

///////////////////////////////////////////////////
// SIGNAL GROUP METHODS
///////////////////////////////////////////////////
// Methods are now embedded directly in their type partials
// This file is preserved for backwards compatibility but no longer needed

// Types with embedded methods

///////////////////////////////////////////////////
// SIGNAL REGISTRY METHODS
///////////////////////////////////////////////////
// Methods are now embedded directly in their type partials
// This file is preserved for backwards compatibility but no longer needed

// Types with embedded methods

///////////////////////////////////////////////////
// UTILITY FUNCTIONS
///////////////////////////////////////////////////

// Add a thought to a signal instance (for visual/logging purposes only)
addThought(SignalInstance signal, string sentiment, string message) =>
    thought = newSignalThought(sentiment, message)
    array.push(signal.thoughts, thought)
    signal

// Get all thoughts for a signal instance
getAllThoughts(SignalInstance signal) =>
    signal.thoughts

// Get the most recent thought
getLatestThought(SignalInstance signal) =>
    if array.size(signal.thoughts) > 0
        array.get(signal.thoughts, array.size(signal.thoughts) - 1)
    else
        newSignalThought("😐", "No interpretation available")

// Clear all thoughts from a signal (useful for testing)
clearThoughts(SignalInstance signal) =>
    signal.thoughts := array.new<SignalThought>()
    signal

// Find configuration for a signal
findConfiguration(SignalRegistry registry, string signalName, string moduleName = "") =>
    for i = 0 to array.size(registry.configurations) - 1
        config = array.get(registry.configurations, i)
        if config.signalName == signalName and (moduleName == "" or config.moduleName == moduleName)
            config
    // Return default configuration if not found
    newSignalConfiguration(signalName, moduleName)

// Add configuration to registry
addConfiguration(SignalRegistry registry, SignalConfiguration config) =>
    array.push(registry.configurations, config)
    registry

// Apply normalization based on configuration
applyNormalization(float rawValue, SignalDefinition definition, SignalConfiguration config) =>
    if config.normalizationScheme == "zscore"
        // Z-score normalization (placeholder - would need historical data)
        rawValue
    else if config.normalizationScheme == "percentile"
        // Percentile normalization (placeholder - would need historical data)
        rawValue
    else
        // Default minmax normalization
        range = definition.maxValue - definition.minValue
        if range > 0
            (rawValue - definition.minValue) / range
        else
            0.5

// Update configuration parameter
updateConfiguration(SignalConfiguration config, string parameter, float value) =>
    switch parameter
        "weight" =>
            config.weight := value
            config
        "thresholdWeak" =>
            config.thresholdWeak := value
            config
        "thresholdStrong" =>
            config.thresholdStrong := value
            config
        => config

// Register a signal definition
registerDefinition(SignalRegistry registry, SignalDefinition definition) =>
    array.push(registry.definitions, definition)
    registry

// Find signal definition by name
findDefinition(SignalRegistry registry, string name) =>
    for i = 0 to array.size(registry.definitions) - 1
        def = array.get(registry.definitions, i)
        if def.name == name
            def
    // Return default if not found
    newSignalDefinition(name, "Unknown signal", -1.0, 1.0, "unknown")

// Add signal group to registry
addGroup(SignalRegistry registry, SignalGroup group) =>
    array.push(registry.groups, group)
    registry

// Find signal group by name
findGroup(SignalRegistry registry, string name) =>
    for i = 0 to array.size(registry.groups) - 1
        group = array.get(registry.groups, i)
        if group.name == name
            group
    // Return null equivalent if not found
    newSignalGroup("NOT_FOUND", "Group not found")

// Add signal to group
addSignalToGroup(SignalGroup group, SignalInstance signal) =>
    array.push(group.signals, signal)
    group

///////////////////////////////////////////////////
// RENDERING HELPERS
///////////////////////////////////////////////////

// Calculate signal strength from raw value, confidence, and configuration
calculateSignalStrength(SignalInstance signal, SignalDefinition definition, SignalConfiguration config) =>
    if na(signal.rawValue) or na(signal.confidence) or not config.enabled
        0.0
    else
        // Apply normalization based on configuration
        normalized = applyNormalization(signal.rawValue, definition, config)

        // Calculate strength as confidence × magnitude from neutral (0.5)
        strength = signal.confidence * math.abs(normalized - 0.5) * 2.0
        math.max(0.0, math.min(1.0, strength))

// Get color based on signal strength and configuration
getStrengthColor(float strength, SignalConfiguration config) =>
    if na(strength) or strength <= config.thresholdWeak
        color.gray
    else if strength >= config.thresholdStrong
        color.new(color.green, 20)
    else
        color.new(color.yellow, 30)

// Get emoji based on signal strength and latest thought sentiment
getDisplayEmoji(SignalInstance signal, float strength) =>
    latestThought = getLatestThought(signal)

    // Prefer thought sentiment if available, otherwise use strength-based emoji
    if latestThought.sentiment != "😐"
        latestThought.sentiment
    else
        switch
            strength >= 0.8 => "⚡"
            strength >= 0.6 => "📈"
            strength >= 0.4 => "📊"
            strength >= 0.2 => "📉"
            => "😐"

// Get directional emoji from raw value
getDirectionEmoji(float rawValue) =>
    switch
        rawValue > 0.1 => "🔼"
        rawValue < -0.1 => "🔽"
        => "➡️"

///////////////////////////////////////////////////
// GROUP AGGREGATION ENGINE
///////////////////////////////////////////////////

// Get the dominant sentiment from an array of signals (using latest thought per signal)
getDominantSentiment(array<SignalInstance> signals) =>
    sentimentCounts = array.new<array<string>>()  // [sentiment, count] pairs

    for i = 0 to array.size(signals) - 1
        signal = array.get(signals, i)
        latestThought = getLatestThought(signal)

        if latestThought.message != "No interpretation available"
            sentiment = latestThought.sentiment
            found = false

            // Look for existing sentiment entry
            for j = 0 to array.size(sentimentCounts) - 1
                pair = array.get(sentimentCounts, j)
                if array.get(pair, 0) == sentiment
                    count = str.tonumber(array.get(pair, 1)) + 1
                    array.set(pair, 1, str.tostring(count))
                    found := true
                    break

            // Add new sentiment entry if not found
            if not found
                array.push(sentimentCounts, array.from(sentiment, "1"))

    // Find most frequent sentiment
    dominantSentiment = "📊"  // default fallback
    maxCount = 0

    for i = 0 to array.size(sentimentCounts) - 1
        pair = array.get(sentimentCounts, i)
        count = str.tonumber(array.get(pair, 1))
        if count > maxCount
            maxCount := count
            dominantSentiment := array.get(pair, 0)

    dominantSentiment

// Summarize thoughts from an array of signals with a maximum number of entries
summarizeThoughts(array<SignalInstance> signals, int maxThoughts) =>
    thoughts = array.new<string>()

    for i = 0 to array.size(signals) - 1
        signal = array.get(signals, i)
        latestThought = getLatestThought(signal)

        if latestThought.message != "No interpretation available"
            thoughtSummary = signal.name + ": " + latestThought.message
            array.push(thoughts, thoughtSummary)

    // Build summary string with semicolon separation
    if array.size(thoughts) == 0
        ""
    else
        summary = ""
        entriesToInclude = math.min(maxThoughts, array.size(thoughts))

        for i = 0 to entriesToInclude - 1
            if i > 0
                summary += "; "
            summary += array.get(thoughts, i)

        summary

// Generate sentiment based on numeric value as fallback
fallbackSentimentFromValue(float value) =>
    switch
        value > 0.3 => "📈"
        value < -0.3 => "📉"
        => "➡️"

// Calculate aggregated signal for group with inherited thoughts
calculateGroupAggregation(SignalGroup group, SignalRegistry registry) =>
    if array.size(group.signals) == 0
        group.aggregatedSignal := newSignalInstance(group.name + "_AGG", na, 0.0)
        addThought(group.aggregatedSignal, "⚠️", "Empty group - no signals to aggregate")
        group

    totalWeightedValue = 0.0
    totalConfidence = 0.0
    totalWeight = 0.0
    validSignals = 0

    for i = 0 to array.size(group.signals) - 1
        signal = array.get(group.signals, i)
        if not na(signal.rawValue)
            // Find configuration for weighting (create default if not found)
            config = na(registry) ? newSignalConfiguration(signal.name) : findConfiguration(registry, signal.name)
            weight = config.enabled ? config.weight : 0.0

            if weight > 0.0
                totalWeightedValue += signal.rawValue * weight
                totalConfidence += signal.confidence * weight
                totalWeight += weight
                validSignals += 1

    if totalWeight > 0
        aggregatedValue = totalWeightedValue / totalWeight
        aggregatedConfidence = totalConfidence / totalWeight

        group.aggregatedSignal := newSignalInstance(
            group.name + "_AGG",
            aggregatedValue,
            aggregatedConfidence
        )

        // Use helper functions for sentiment and summary generation
        dominantSentiment = getDominantSentiment(group.signals)

        // Fallback to value-based sentiment if no clear dominant sentiment found
        if dominantSentiment == "📊"
            dominantSentiment := fallbackSentimentFromValue(aggregatedValue)

        // Build comprehensive summary with inherited context
        summary = "Aggregated from " + str.tostring(validSignals) + " signals"
        thoughtsSummary = summarizeThoughts(group.signals, 3)

        if thoughtsSummary != ""
            summary += " | Key insights: " + thoughtsSummary

        addThought(group.aggregatedSignal, dominantSentiment, summary)
    else
        group.aggregatedSignal := SignalInstance.new(group.name + "_AGG", na, 0.0, array.new<SignalThought>())
        addThought(group.aggregatedSignal, "⚠️", "No valid signals for aggregation")

    group

// SignalGroup aggregation method
method calculateAggregation(SignalGroup this, SignalRegistry registry) =>
    calculateGroupAggregation(this, registry)

///////////////////////////////////////////////////
// ARCHITECTURE SUMMARY
///////////////////////////////////////////////////
//
// CORE DESIGN PRINCIPLES:
//
// 1. STRUCTURE vs BEHAVIOR SEPARATION:
//    - SignalDefinition: Immutable declaration of what the signal measures
//    - SignalConfiguration: Mutable behavioral settings (weights, thresholds, etc.)
//
// 2. DATA vs INTERPRETATION SEPARATION:
//    - SignalInstance: Pure numeric observations and confidence scores
//    - SignalThought: Optional human-readable interpretations for visual/logging
//
// 3. STATIC vs RUNTIME BOUNDARIES:
//    - Static: Definitions and configurations (network structure)
//    - Runtime: Signal instances, thoughts, and group evaluations
//
// 4. THOUGHTS ARE LIGHTWEIGHT:
//    - Optional array for visual/debugging purposes only
//    - Do not affect core signal logic or calculations
//    - Used purely for human-readable context and logging
//
// 5. MODULAR DESIGN:
//    - Each module focuses on a specific aspect of the type system
//    - Types, factories, methods, utilities, and aggregation are separated
//    - Enables easy maintenance and extension of functionality
//
///////////////////////////////////////////////////

